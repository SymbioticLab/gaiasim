package gaiasim.scheduler;

// The scheduler for Siphon
// Paper ref: https://www.usenix.org/system/files/conference/atc18/atc18-liu.pdf

// How to implement Siphon scheduler?
// Use Oracle FCT to sort Coflows
// Use LFGF to schedule flows of a Coflow
// After scheduling, run the bottleneck shifting algorithm for multipath


import com.opencsv.CSVReader;
import gaiasim.network.*;

import java.io.IOException;
import java.io.Reader;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;

@SuppressWarnings("Duplicates")

public class SiphonScheduler extends MultiPathScheduler {

    int monteCarloN = 100;
    int monteCarloDepth = 3; // default depth = 5
    int multipathIterations = 5; // default, iterate the process of shifting traffic 1 times
    Map<String, Double> oracleCCT = new HashMap<>();

    public SiphonScheduler(NetGraph net_graph, String oracleCCT_filename) {
        super(net_graph);
        readOracleCCT(oracleCCT_filename);
    }

    // method called in constructor should be final.
    private final void readOracleCCT(String oracleFCT_filename) {

        // read in a list of flow completion time, as the oracleCCT
        // The oracle CCT should be a csv file generated by the per-flow solution (ideally with one-by-one option)

        try (
                Reader reader = Files.newBufferedReader(Paths.get(oracleFCT_filename));
                CSVReader csvReader = new CSVReader(reader, ',', '"', 1)
        ) {
            // Reading Records One by One in a String array
            String[] nextRecord;
            while ((nextRecord = csvReader.readNext()) != null) {
//                System.out.println("CF ID : " + nextRecord[0]);
//                System.out.println("Start : " + nextRecord[1]);
//                System.out.println("End : " + nextRecord[2]);
//                System.out.println("CCT : " + nextRecord[3]);
//                System.out.println("==========================");
                oracleCCT.put(nextRecord[0], Double.parseDouble(nextRecord[3]));
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    @Override
    public HashMap<String, Flow> schedule_flows(HashMap<String, Coflow> coflows, long timestamp) throws Exception {

        long schedStart = System.nanoTime();
        flows_.clear();
        reset_links();

        // Hashmap or list?
//        HashMap<String, Coflow> coflows_to_schedule = (HashMap<String, Coflow>) coflows.clone();
        Collection<Coflow> coflows_to_schedule = new LinkedList<>();
        coflows_to_schedule.addAll(coflows.values());
        ArrayList<Coflow> unscheduled_coflows = new ArrayList<>();

        while (!coflows_to_schedule.isEmpty()) {

            // Use Oracle FCT to sort Coflows to find the next coflow to schedule
            Coflow cf_to_schedule = findNextCoflow_fromCCT(coflows_to_schedule);

            // We consider one coflow at a time
//            coflows_to_schedule.clear();
            // remove the scheduled coflow from the collection and repeat the scheduling process
            coflows_to_schedule.remove(cf_to_schedule);

            // verify that this coflow is fully schedulable
            if (!fully_schedulable(cf_to_schedule)) {
                System.out.println("Coflow " + cf_to_schedule.id_ + " is not fully schedulable.");
                unscheduled_coflows.add(cf_to_schedule);
                continue;
            }

            // LFGF to schedule flows of a Coflow
            // 1. group flows by their reduce task (dst loc), and find the ones with the biggest size

            Map<String, Double> FG_Size_Map = cf_to_schedule.flows_.values().stream().collect(Collectors.groupingBy(
                    Flow::getDst_loc_, Collectors.summingDouble(Flow::remaining_volume)));

            LinkedList<Map.Entry<String, Double>> FG_Size_list = new LinkedList<>(FG_Size_Map.entrySet());
            FG_Size_list.sort(Map.Entry.comparingByValue());

            // 2. find the shortest path for each flow and allocate BW
// Ignore coflow that cannot be scheduled in its entirety

            for (Map.Entry<String, Double> fge : FG_Size_list) {
                String dst_loc = fge.getKey();

                // Find all flows that have this dst_loc, and schedule them

                for (Flow f : cf_to_schedule.flows_.values()) {
                    // Ensure this flow is not done and also is within the prioritized group
                    if (f.done_ || !f.dst_loc_.equals(dst_loc)) {
                        continue;
                    }

                    System.out.println("Scheduling Flow " + f.id_);

                    // This is the shortest path
                    Pathway p = new Pathway(net_graph_.apsp_[Integer.parseInt(f.src_loc_)][Integer.parseInt(f.dst_loc_)]);
                    f.paths_.clear();
                    f.paths_.add(p);

                    // Subscribe all links on this path
                    for (int i = 0; i < p.node_list_.size() - 1; i++) {
                        int src = Integer.parseInt(p.node_list_.get(i));
                        int dst = Integer.parseInt(p.node_list_.get(i + 1));
                        links_[src][dst].subscribers_.addAll(f.paths_);
                    }

                    // Init the start time stamp
                    if (f.start_timestamp_ == -1) {
                        f.start_timestamp_ = timestamp;
                    }

                    flows_.put(f.id_, f);

                    // Reserve full BW for this flow, because it is scheduled earlier than other flows
                    double min_bw = Double.MAX_VALUE;

                    ArrayList<String> nodes = f.paths_.get(0).node_list_;
                    for (int i = 0; i < nodes.size() - 1; i++) {
                        int src = Integer.parseInt(nodes.get(i));
                        int dst = Integer.parseInt(nodes.get(i + 1));
                        double link_bw = links_[src][dst].bw_per_flow();

                        if (link_bw < min_bw) {
                            min_bw = link_bw;
                        }
                    }

                    f.rate_ = min_bw;
                    f.paths_.get(0).bandwidth_ = min_bw; // until now there is only one path
                    System.out.println("Flow " + f.id_ + " has rate " + f.rate_ + " and remaining volume " + (f.volume_ - f.transmitted_) + " on path " + f.paths_.get(0));
                }
            }

            // This coflow finished scheduling.

        }

        // After scheduling, run the bottleneck shifting algorithm for multipath
        shiftTraffic(null, flows_, timestamp);

        // Performance gets slightly better if not enabling this. about 10%. But we should enable this
        update_flows(flows_);

        long schedEnd = System.nanoTime();
        int currentD = Math.min(coflows.size(), monteCarloDepth);
        double scaledScheduleTime = (double) (schedEnd - schedStart) / 1000 / 1000 * Math.pow(monteCarloN, currentD);
        System.out.println("schedule took " + scaledScheduleTime + " ms. " + currentD);

        if (!unscheduled_coflows.isEmpty()) {
            schedule_extra_flows(unscheduled_coflows, timestamp); // This is the optimization from Varys
//            distributeBandwidth(unscheduled_coflows, timestamp); // This is the optimization from Rapier
        }

        return flows_;
    }

    private void shiftTraffic(Coflow cf_to_schedule, HashMap<String, Flow> flows_, long timestamp) {

        if (flows_.isEmpty()) {
            return;
        }

        for (int iter = 0; iter < multipathIterations; iter++) {
            // Each iteration we find one bottleneck link, and shift its traffic
            // Bottleneck link: the link that has the highest utilization

            // Search for highest utilization link
            Map<SubscribedLink, Double> linkUtilMap = new HashMap<>();
            int maxLinkSrc = -1;
            int maxLinkDst = -1;
            double maxLinkUtil = 0;

            // iterate through scheduled flows, and add up the link utilization
            for (Map.Entry<String, Flow> flowEntry : flows_.entrySet()) {
                Flow flow = flowEntry.getValue();

                for (Pathway pathway : flow.paths_) {
                    for (int i = 0; i < pathway.node_list_.size() - 1; i++) {
                        int src = Integer.parseInt(pathway.node_list_.get(i));
                        int dst = Integer.parseInt(pathway.node_list_.get(i + 1));

                        SubscribedLink link = links_[src][dst];
                        if (linkUtilMap.containsKey(link)) {
                            double sumUtil = linkUtilMap.get(link) + flow.remaining_volume() / link.max_bw_;
                            linkUtilMap.put(link, sumUtil);
                            if (sumUtil > maxLinkUtil) {
                                maxLinkUtil = sumUtil;
                                maxLinkSrc = src;
                                maxLinkDst = dst;
                            }
                        } else {
                            double sumUtil = flow.remaining_volume() / link.max_bw_;
                            linkUtilMap.put(link, sumUtil);
                            if (sumUtil > maxLinkUtil) {
                                maxLinkUtil = sumUtil;
                                maxLinkSrc = src;
                                maxLinkDst = dst;
                            }
                        }
                    }
                }
            }

            // Now we have found the maxUtil Link, see if we can divert any traffic
            // Do an exhaustive search of all possible path between these two nodes,
            // along all paths that have any remaining BW.

            // A BFS search for path
            boolean found_a_path = false;
            int s = maxLinkSrc;
            int d = maxLinkDst;

            int V = net_graph_.nodes_.size() + 1;
            // Mark all the vertices as not visited(By default set as false)
            boolean visited[] = new boolean[V];

            // Create a queue for BFS
            LinkedList<LinkedList<Integer>> queue = new LinkedList<>();

            // Mark the current node as visited and enqueue it
            visited[s] = true;
            LinkedList<Integer> list_s = new LinkedList<Integer>();
            list_s.add(s);
            queue.add(list_s);

            // 'i' will be used to get all adjacent vertices of a vertex
//            Iterator<Integer> i;
            while (queue.size() != 0) {
                // Dequeue a vertex from queue and print it
                list_s = queue.poll();
                s = list_s.getLast();

                // Iterate through unvisited neighbors
                for (int i = 0; i < V; i++) {
                    if (i == s || links_[s][i] == null) {
                        continue;
                    }

                    if (links_[s][i].max_bw_ <= links_[s][i].subscribers_.stream().mapToDouble(Pathway::getBandwidth_).sum()) {
                        continue;
                    }

                    if (i == d) {
                        // we found a path
                        list_s.add(d);
                        found_a_path = true;
                        break;
                    }

                    if (!visited[i]) {
                        visited[i] = true;

                        // Create new LinkedList representing the path
                        LinkedList<Integer> list_i = new LinkedList<Integer>();
                        list_i.addAll(list_s);
                        list_i.add(i);

                        queue.add(list_i);
                    }
                }
            }

            if (found_a_path) {
                // Now list_s is the path, now we need to assign a flow to this path

                LinkedList<Flow> flows_to_share_path = new LinkedList<>();

                // flow_ is worse than coflow set when in the loop
                for (Map.Entry<String, Flow> flowEntry : flows_.entrySet()) {
                    Flow f = flowEntry.getValue();
                    if (Integer.parseInt(f.src_loc_) == maxLinkSrc && Integer.parseInt(f.dst_loc_) == maxLinkDst) {
                        flows_to_share_path.add(f);
                    }
                }

                double min_bw = Double.MAX_VALUE;
                for (int i = 0; i < list_s.size() - 1; i++) {
                    int src = list_s.get(i);
                    int dst = list_s.get(i + 1);
                    double link_bw = links_[src][dst].remaining_bw();

                    if (link_bw < min_bw) {
                        min_bw = link_bw;
                    }
                }

                for (Flow flow : flows_to_share_path) {

                    // Construct the path for each flow and add to it.
                    Pathway p = new Pathway();
                    p.bandwidth_ = min_bw / flows_to_share_path.size();
                    p.node_list_.add(String.valueOf(list_s.getFirst()));

                    for (int i = 0; i < list_s.size() - 1; i++) {
                        int src = list_s.get(i);
                        int dst = list_s.get(i + 1);

                        // Construct path
                        p.node_list_.add(String.valueOf(dst));

                        // Also add subscription
//                        if (links_[src][dst].subscribers_.isEmpty())
                        links_[src][dst].subscribers_.add(p);
                    }

                    flow.paths_.add(p);
                    flow.rate_ += p.bandwidth_;

                    // If this flow is first time scheduled
                    // Init the start time stamp
                    if (flow.start_timestamp_ == -1) {
                        flow.start_timestamp_ = timestamp;
                        flows_.put(flow.id_, flow);
                    }
                }
            }
        }
    }

    // Find the next coflow to schedule (the one with min CCT)

    private Coflow findNextCoflow_fromCCT(Collection<Coflow> coflows_to_schedule) {

        //        Don't use Monte Carlo here, because the duration is deterministic
//        int depth = Math.min(monteCarloDepth, coflows_to_schedule.size());

        Coflow ret = null;
        double minCCT = Double.MAX_VALUE;
        // Iterate through all coflows and find the one with min CCT
        for (Coflow cf : coflows_to_schedule) {

            // Get Max FCT for this coflow
            Double cct = oracleCCT.get(cf.id_);
            if (cct != null && minCCT > cct) {
                minCCT = cct;
                ret = cf;
            }
        }

        return ret;
    }

    // Do not override here.
//    // Updates the rates of flows
//    public void update_flows(HashMap<String, Flow> flows) {
//        // For each flow find bottleneck link and get its BW. (Do we need to fair share here)
//        for (Map.Entry<String, Flow> flowEntry : flows.entrySet()) {
//            Flow f = flowEntry.getValue();
//
//            double min_bw = Double.MAX_VALUE;
//
//            ArrayList<String> nodes = f.paths_.get(0).node_list_;
//            for (int i = 0; i < nodes.size() - 1; i++) {
//                int src = Integer.parseInt(nodes.get(i));
//                int dst = Integer.parseInt(nodes.get(i + 1));
//                double link_bw = links_[src][dst].bw_per_flow();
//
//                if (link_bw < min_bw) {
//                    min_bw = link_bw;
//                }
//            }
//
//            f.rate_ = min_bw;
//            System.out.println("Flow " + f.id_ + " has rate " + f.rate_ + " and remaining volume " + (f.volume_ - f.transmitted_) + " on path " + f.paths_.get(0));
//        }
//    }

    // Check if a coflow is fully scheduleable, borrowed from Varys.
    private boolean fully_schedulable(Coflow c) {
        boolean no_overlap = true;

        for (String k_ : c.flows_.keySet()) {
            Flow f = c.flows_.get(k_);
            if (f.done_) {
                continue;
            }

            Pathway p = new Pathway(net_graph_.apsp_[Integer.parseInt(f.src_loc_)][Integer.parseInt(f.dst_loc_)]);
            f.paths_.clear();

            for (int i = 0; i < p.node_list_.size() - 1; i++) {
                int src = Integer.parseInt(p.node_list_.get(i));
                int dst = Integer.parseInt(p.node_list_.get(i + 1));
                if (!links_[src][dst].subscribers_.isEmpty()) {
                    no_overlap = false;
                    break;
                }
            }
        }

        return no_overlap;
    }

   /* private Coflow findNextCoflow_fromFCT(Collection<Coflow> coflows_to_schedule) {

//        Don't use Monte Carlo here, because the duration is deterministic
//        int depth = Math.min(monteCarloDepth, coflows_to_schedule.size());

        Coflow ret = null;
        double minCCT = Double.MAX_VALUE;
        // Iterate through all coflows and find the one with min CCT
        for (Coflow cf : coflows_to_schedule) {

            // Get Max FCT for this coflow
            double maxFCT = 0;
            for (Flow f : cf.flows_.values()) {
                Double fct = oracleFCT.get(f.id_);
                if (fct != null && fct > maxFCT) {
                    maxFCT = fct;
                }
            }

            if (maxFCT != 0 && maxFCT < minCCT) {
                minCCT = maxFCT;
                ret = cf;
            }
        }

        return ret;
    }*/

    public void distributeBandwidth(ArrayList<Coflow> unscheduled_coflows, long timestamp) {
        // first sort the Coflows according to the MinCCT
        // But they should all have minCCT == -1, so no need to sort!
        // TODO may change here
        for (Coflow cf : unscheduled_coflows) {
            assignBWforCF(cf, timestamp);
        }
    }

    public void assignBWforCF(Coflow cf, long timestamp) {
        ArrayList<Flow> flows = new ArrayList<Flow>(cf.flows_.values());
        boolean isScheduled = false;

        Collections.sort(flows, Comparator.comparingDouble(o -> o.remaining_volume()));
        // then from large flow to small flow
        for (int i = flows.size() - 1; i >= 0; i--) {
            Flow flow = flows.get(i);
            boolean thisFLowScheduled = assignBWforFlow_MaxSinglePath(flow, timestamp);
            if (thisFLowScheduled) {
                isScheduled = true;
                flows_.put(flow.id_, flow);
            }
        }

        if (isScheduled) {
            cf.last_scheduled_timestamp = timestamp;
        }
    }

    private void schedule_extra_flows(ArrayList<Coflow> unscheduled_coflows, long timestamp) {
        for (Coflow c : unscheduled_coflows) {
            for (String k_ : c.flows_.keySet()) {
                Flow f = c.flows_.get(k_);
                if (f.done_) {
                    continue;
                }

                Pathway p = new Pathway(net_graph_.apsp_[Integer.parseInt(f.src_loc_)][Integer.parseInt(f.dst_loc_)]);
                f.paths_.clear();
                f.paths_.add(p);

                boolean no_overlap = true;
                for (int i = 0; i < p.node_list_.size() - 1; i++) {
                    int src = Integer.parseInt(p.node_list_.get(i));
                    int dst = Integer.parseInt(p.node_list_.get(i + 1));
                    if (!links_[src][dst].subscribers_.isEmpty()) {
                        no_overlap = false;
                        break;
                    }
                }

                if (no_overlap) {
                    for (int i = 0; i < p.node_list_.size() - 1; i++) {
                        int src = Integer.parseInt(p.node_list_.get(i));
                        int dst = Integer.parseInt(p.node_list_.get(i + 1));
                        links_[src][dst].subscribers_.addAll(f.paths_);
                    }

                    if (f.start_timestamp_ == -1) {
                        f.start_timestamp_ = timestamp;
                    }

                    flows_.put(f.id_, f);
                }
            }
        }
    }
}
